<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/http.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/http.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import CryptoJS from "crypto-js"
import https from "https"
import("../types/http.types.js")

/**
 * @namespace
 */
export class Http {
    HmacSHA256 = CryptoJS.HmacSHA256

    /**
     * @param {HttpConstructor} options
     */
    constructor(options) {
        this.api_key = options.api_key
        this.api_secret = options.api_secret
        this.isTestNet = options.isTestNet
        this.recvWindow = options.recvWindow

        this.baseURL = options.baseURL
        this.baseURLTest = options.baseURLTest
        this.timestamp = options.timestamp
    }

    /**
     * @param {String} hostname example: catfact.ninja
     * @param {String} [path] example: /fact
     * @param {Object} options 
     * @param {"GET" | "POST" | "PUT" | "DELETE" | "OPTIONS"} [options.method] or anything else
     * @param {Object} [options.headers]
     * @param {String} [options.body] if its object, it should be JSON.stringify
     * @returns {Promise&lt;Buffer | JSON>}
     */
    async httpRequest(hostname, path="", options) {

        return new Promise((resolve, reject) => {

            function callback(res) {
                // if (res.statusCode &lt; 200 || res.statusCode >= 300) {
                //     return reject(new Error(res.statusCode))
                // }

                let resBody = []
                
                res.on('data', function(chunk) {
                    resBody.push(chunk)
                })

                res.on('end', function() {
                    try {
                        resBody = Buffer.concat(resBody)
 
                        let contentType = res.headers['content-type']
                        if (contentType) {
                            if (contentType.includes("application/json")) {
                                resBody = JSON.parse(resBody)
                            }
                        }

                        // else Buffer
                        resolve({
                            body: resBody,
                            statusCode: res.statusCode,
                            statusMessage: res.statusMessage,
                            headers: res.headers,
                        })
                    } catch(error) {
                        reject(error)
                    }
                })    
            }
            
            // remove https:// OR http:// from hostname
            if (hostname.startsWith("https://")) {
                hostname = hostname.replace("https://", "")
            } else if (hostname.startsWith("http://")) {
                hostname = hostname.replace("http://", "")
            }

            let criteria = {}

            criteria.hostname = hostname

            if (path) {
                criteria.path = path
            }

            if (options?.headers) {
                criteria.headers = options.headers
            }

            if (options?.method) {
                criteria.method = options.method
            } else {
                criteria.method = "GET"
            }
            
            const req = https.request({...criteria}, callback)
            
            req.on('error', (error) => {
                reject(error.message)
            })

            if (options?.body) {
                req.write(options.body)
            }

            req.end()
        })
    }

    /**
     * @type {HttpRequest}
     */
    async request(method, address, params = {}, isPrivate = false, noTimestampAndRecvWindow=false) {
        try {

            let hostname = this.baseURL 
            if (this.isTestNet) {
                console.log("## Test Net Request ##")
                hostname = this.baseURLTest
            }

            let recvWindow = this.recvWindow
            if (params.recvWindow) {
                recvWindow = params.recvWindow
                delete params.recvWindow
            }

            let queries = {
                ...params,
                timestamp: this.timestamp,
                recvWindow,
            }

            if (noTimestampAndRecvWindow) {
                delete queries.timestamp
                delete queries.recvWindow
            }

            let queryToString = Object.keys(queries)
                .map((key) => {
                    let value = queries[key]

                    if (value instanceof Array) {
                        value = JSON.stringify(value)
                        value = encodeURI(value)
                    }
                    return `${key}=${value}`
                })
                .join("&amp;");

            let headers = {}
            
            if (method != "GET") {
                headers["Accept"] = "application/x-www-form-urlencoded"
            }

            if (isPrivate &amp;&amp; this.api_secret) {
                const signature = this.HmacSHA256(
                    queryToString,
                    this.api_secret
                ).toString()

                address = address + "?" + queryToString + "&amp;signature=" + signature
            } else {
                address = address + "?" + queryToString
            }

            if (this.api_key) {
                headers["X-MBX-APIKEY"] = this.api_key
            }
            
            let req = await this.httpRequest(hostname, address, {
                method,
                headers,
            })
            // console.log("BODY:", req.body)
            // console.log("Status Code:", req.statusCode)
            // console.log("Status Message:", req.statusMessage)
            // console.log("Headers:", req.headers)

            if (req.status == 404) {
                throw new Error("404 not found")
            } else if (req.status == 406) {
                throw new Error("Client error 406: something you should fix")
            }
            
            return req.body
        } catch (error) {
            let errorMessage = {
                name: error.name,
                message: error.message,
                stack: error.stack,
            }

            return errorMessage
        }
    }

    /**
     * it's using fetch module which is available on node 18.0.0 and higher
     * so due to compatibility we are disabling it.
     * so this is PRAISE (opposite of DEPRECATE)
     * @type {HttpRequest}
     */
    async PRAISE_request(method, address, params = {}, isPrivate = false, noTimestampAndRecvWindow=false) {
        try {
            if (this.isTestNet) {
                console.log("## Test Net Request ##")
                address = this.baseURLTest + address
            } else {
                address = this.baseURL + address
            }

            let recvWindow = this.recvWindow
            if (params.recvWindow) {
                recvWindow = params.recvWindow
                delete params.recvWindow
            }

            let queries = {
                ...params,
                timestamp: this.timestamp,
                recvWindow,
            }

            if (noTimestampAndRecvWindow) {
                delete queries.timestamp
                delete queries.recvWindow
            }

            let queryToString = Object.keys(queries)
                .map((key) => {
                    let value = queries[key]

                    if (value instanceof Array) {
                        value = JSON.stringify(value)
                        value = encodeURI(value)
                    }
                    return `${key}=${value}`
                })
                .join("&amp;");

            let headers = {}
            
            if (method != "GET") {
                headers["Accept"] = "application/x-www-form-urlencoded"
            }

            if (isPrivate &amp;&amp; this.api_secret) {
                const signature = this.HmacSHA256(
                    queryToString,
                    this.api_secret
                ).toString()

                address = address + "?" + queryToString + "&amp;signature=" + signature
            } else {
                address = address + "?" + queryToString
            }

            if (this.api_key) {
                headers["X-MBX-APIKEY"] = this.api_key
            }

            let data = await fetch(address, {
                method,
                headers,
            })

            if (data.status == 404) {
                throw new Error("404 not found")
            } else if (data.status == 406) {
                throw new Error("Client error 406: something you should fix")
            }

            let body = await data.json()
            // console.log(body)
            return body

        } catch (error) {
            let errorMessage = {
                name: error.name,
                message: error.message,
                stack: error.stack,
            }

            return errorMessage
        }
    }

    // ############## Requests without timestamp &amp; recvWindow
    /**
     * @type {HttpPublic}
     */
    async simplePublicGET(address, params = {}) {
        return await this.request("GET", address, params, false, true)
    }

    /**
     * @type {HttpPublic}
     */
    async simplePublicPOST(address, params = {}) {
        return await this.request("POST", address, params, false, true)
    }

    /**
     * @type {HttpPublic}
     */
    async simplePublicPUT(address, params = {}) {
        return await this.request("PUT", address, params, false, true)
    }

    /**
     * @type {HttpPublic}
     */
    async simplePublicDELETE(address, params = {}) {
        return await this.request("DELETE", address, params, false, true)
    }


    /**
     * @type {HttpPrivate}
     */
    async simplePrivateGET(address, params={}) {
        return await this.request("GET", address, params, true, true)
    }

    /**
     * @type {HttpPrivate}
     */
    async simplePrivatePOST(address, params={}) {
        return await this.request("POST", address, params, true, true)
    }

    /**
     * @type {HttpPrivate}
     */
    async simplePrivatePUT(address, params={}) {
        return await this.request("PUT", address, params, true, true)
    }

    /**
     * @type {HttpPrivate}
     */
    async simplePrivateDELETE(address, params={}) {
        return await this.request("DELETE", address, params, true, true)
    }
    // ############## Full Requests
    /**
     * @type {HttpPublic}
     */
    async publicGET(address, params = {}) {
        return await this.request("GET", address, params, false)
    }

    /**
     * @type {HttpPublic}
     */
    async publicPOST(address, params = {}) {
        return await this.request("POST", address, params, false)
    }

    /**
     * @type {HttpPublic}
     */
    async publicPUT(address, params = {}) {
        return await this.request("PUT", address, params, false)
    }

    /**
     * @type {HttpPublic}
     */
    async publicDELETE(address, params = {}) {
        return await this.request("DELETE", address, params, false)
    }

    /**
     * @type {HttpPrivate}
     */
    async privateGET(address, params={}) {
        return await this.request("GET", address, params, true)
    }

    /**
     * @type {HttpPrivate}
     */
    async privatePOST(address, params={}) {
        return await this.request("POST", address, params, true)
    }

    /**
     * @type {HttpPrivate}
     */
    async privatePUT(address, params={}) {
        return await this.request("PUT", address, params, true)
    }

    /**
     * @type {HttpPrivate}
     */
    async privateDELETE(address, params={}) {
        return await this.request("DELETE", address, params, true)
    }

    /**
     * @type {HttpPublicRequest}
     */
    async publicRequest(method, address, params = {}) {
        return await this.request(method, address, params, false)
    }

    /**
     * @type {HttpPrivateRequest}
     */
    async privateRequest(method, address, params = {}) {
        return await this.request(method, address, params, true)
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="BlvtStream.html">BlvtStream</a></li><li><a href="CoinM.html">CoinM</a></li><li><a href="EuOptions.html">EuOptions</a></li><li><a href="Futures.html">Futures</a></li><li><a href="Http.html">Http</a></li><li><a href="Spot.html">Spot</a></li><li><a href="Websocket_.html">Websocket</a></li></ul><h3>Classes</h3><ul><li><a href="CloseEvent.html">CloseEvent</a></li><li><a href="ErrorEvent.html">ErrorEvent</a></li><li><a href="Event.html">Event</a></li><li><a href="Limiter.html">Limiter</a></li><li><a href="MessageEvent.html">MessageEvent</a></li><li><a href="PerMessageDeflate.html">PerMessageDeflate</a></li><li><a href="Receiver.html">Receiver</a></li><li><a href="Sender.html">Sender</a></li><li><a href="WebSocket.html">WebSocket</a></li><li><a href="WebSocketServer.html">WebSocketServer</a></li></ul><h3>Mixins</h3><ul><li><a href="EventTarget.html">EventTarget</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_append">_append</a></li><li><a href="global.html#_createHelper">_createHelper</a></li><li><a href="global.html#_createHmacHelper">_createHmacHelper</a></li><li><a href="global.html#_isValidUTF8">_isValidUTF8</a></li><li><a href="global.html#_mask">_mask</a></li><li><a href="global.html#_parse">_parse</a></li><li><a href="global.html#_process">_process</a></li><li><a href="global.html#_unmask">_unmask</a></li><li><a href="global.html#cfg">cfg</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#compute">compute</a></li><li><a href="global.html#concat">concat</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createDecryptor">createDecryptor</a></li><li><a href="global.html#createEncryptor">createEncryptor</a></li><li><a href="global.html#createWebSocketStream">createWebSocketStream</a></li><li><a href="global.html#decrypt">decrypt</a></li><li><a href="global.html#encrypt">encrypt</a></li><li><a href="global.html#extend">extend</a></li><li><a href="global.html#finalize">finalize</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#isValidStatusCode">isValidStatusCode</a></li><li><a href="global.html#mixIn">mixIn</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#processBlock">processBlock</a></li><li><a href="global.html#random">random</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#toArrayBuffer">toArrayBuffer</a></li><li><a href="global.html#toBuffer">toBuffer</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#toX32">toX32</a></li><li><a href="global.html#update">update</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Wed Nov 30 2022 22:00:31 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
